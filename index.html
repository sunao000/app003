<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>等間隔休憩+POIラベル+標高考慮ルート案内</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    #map { height: 500px; }
    #controls { margin: 10px 0; display:flex; flex-wrap:wrap; gap:6px; align-items:center; }
    #searchResults { max-height: 150px; overflow-y: auto; list-style: none; border: 1px solid #ccc; }
    #searchResults li:hover { background-color: #eee; cursor: pointer; }
    #pointList { list-style: none; padding-left: 0; }
    #pointList li { padding: 4px; border: 1px solid #ccc; margin-bottom: 4px; background: #fafafa; cursor: move; display: flex; justify-content: space-between; align-items: center; }
    #pointList li span.role-name { flex-grow: 1; }
    #distanceChartContainer { display: none; margin-top: 20px; background-color: #fff; padding: 10px; }
    #progressStatus { margin: 6px 0; color: #ff9900; font-weight: bold; min-height:1.5em; }
    .legend-steep { display:inline-block; border-radius:8px; padding:2px 10px; margin-right:10px; }
    .legend-blue { background:#6ab4ff; color:#003366;}
    .legend-red  { background:#ffaaa2; color:#7a001b;}
    .legend-orange{background:#ffd966; color:#a87d00;}
    .legend-gray { background:#bcbcbc; color:#333;}
  </style>
</head>
<body style="background-color: white;">
  <h2>等間隔休憩+POIラベル+標高考慮ルート案内</h2>

  <!-- ===== 操作パネル ===== -->
  <div id="controls">
    <input id="placeInput" type="text" placeholder="地名・住所を入力" style="width: 240px;" />
    <button id="clearPlaceInputBtn">×</button>
    <button id="searchPlaceBtn">地名検索</button>
    <label><input type="checkbox" id="nearbyOnlyCheckbox" /> 近くの場所のみ検索</label>
    <button id="addCurrentBtn">現在地を追加</button>
    <button id="toggleRealTimeBtn">リアルタイム現在地更新 OFF</button>
    <button id="drawRouteBtn">坂ルート表示</button>

    <!-- 休憩インターバル -->
    <label style="display:flex; align-items:center; gap:4px;">
      <input type="checkbox" id="restCheckbox" />
      <input type="number" id="restTimeInput" value="60" min="1" style="width:60px;" disabled /> 分ごとに休憩 (コンビニ/スーパー/道の駅)
    </label>

    <button id="downloadCsvBtn">スコアCSVダウンロード</button>
    <button id="downloadGraphBtn">距離グラフダウンロード</button>

    <!-- プロファイル -->
    <select id="profileSelect">
      <option value="foot-walking">徒歩</option>
      <option value="driving-car">車</option>
      <option value="cycling-regular">自転車（一般）</option>
      <option value="cycling-road" selected>ロードバイク</option>
      <option value="cycling-mountain">マウンテンバイク</option>
      <option value="cycling-electric">E-Bike</option>
    </select>
    <div id="routeInfo" style="margin-left:8px;"></div>
  </div>

  <!-- 凡例 -->
  <div>
    <span class="legend-steep legend-blue">青：坂が少ないルート</span>
    <span class="legend-steep legend-red">赤：坂が多いルート</span>
    <span class="legend-steep legend-orange">黄：POI（コンビニ/スーパー/道の駅）</span>
    <span class="legend-steep legend-gray">灰：POIなしの仮休憩</span>
  </div>

  <div id="progressStatus"></div>
  <h3>登録地点リスト（ドラッグで並び替え可能）</h3>
  <ul id="pointList"></ul>
  <ul id="searchResults"></ul>
  <div id="map"></div>

  <!-- 距離グラフ -->
  <div id="distanceChartContainer">
    <canvas id="distanceChart" width="800" height="400" style="background-color: white;"></canvas>
  </div>

  <!-- ===== ライブラリ ===== -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/sortablejs@latest/Sortable.min.js"></script>

  <!-- ===== メインスクリプト ===== -->
  <script>
    /* --------------------
       0.  グローバル定数
    -------------------- */
    const apiKey              = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9';    // ←★★ 自分の ORS API キーに置換
    const AUTO_REDRAW_DISTANCE= 50;                // [m] リアルタイム更新で何 m 動いたら再計算
    const POI_SEARCH_RADIUS   = 1000;              // [m] ルート→POI バッファ
    const REST_POI_CATEGORIES = [533, 532, 414];   // コンビニ/スーパー/道の駅

    /* 休憩スコア関連係数（調整可）*/
    const INTERVAL_MIN        = () => Number(restTimeInput.value || 60); // 分
    const MAX_LATERAL         = 200;   // [m] これ以上横に逸れたら対象外
    const MAX_TIME_DIFF       = 600;   // [s]  ±10 分以上ずれたら対象外
    const W_TIME  = 3;   // weight for timeDiff
    const W_DIST  = 1;   // weight for lateralDist
    const W_ASC   = -1;  // weight for ascendPrev (負にして“登り後休憩”優遇)
    const ASCEND_LOOKBACK = 5; // 直前 N 頂点の登り量で評価

    /* --------------------
       1.  Leaflet 初期化
    -------------------- */
    const map = L.map('map').setView([35.681236, 139.767125], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution:'&copy; OpenStreetMap contributors'
    }).addTo(map);

    /* カスタムアイコン */
    const iconStart  = new L.Icon({ iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png',  iconSize:[32,32], iconAnchor:[16,32]});
    const iconVia    = new L.Icon({ iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/blue-dot.png',   iconSize:[32,32], iconAnchor:[16,32]});
    const iconEnd    = new L.Icon({ iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png',    iconSize:[32,32], iconAnchor:[16,32]});
    const iconRest   = new L.Icon({ iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/orange-dot.png', iconSize:[32,32], iconAnchor:[16,32]});
    const iconRestG  = new L.Icon({ iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/ltgray-dot.png', iconSize:[32,32], iconAnchor:[16,32]});

    /* DOM ショートカット */
    const $ = id => document.getElementById(id);
    const placeInput  = $('placeInput');
    const nearBox     = $('nearbyOnlyCheckbox');
    const searchResults = $('searchResults');
    const restCheckbox = $('restCheckbox');
    const restTimeInput= $('restTimeInput');
    const pointList   = $('pointList');
    const routeInfo   = $('routeInfo');
    const progressStatus = $('progressStatus');
    const profileSelect  = $('profileSelect');

    /* チェックボックスで休憩分入力の on/off */
    restCheckbox.addEventListener('change', ()=>{ restTimeInput.disabled = !restCheckbox.checked; });

    /* --------------------
       2.  汎用関数
    -------------------- */
    const toRad = d => d*Math.PI/180;
    const haversine = (lat1,lng1,lat2,lng2)=>{
      const R=6371000;
      const dLat=toRad(lat2-lat1), dLng=toRad(lng2-lng1);
      const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLng/2)**2;
      return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    };
    const clearLayers = arr => { arr.forEach(m=>map.removeLayer(m)); arr.length=0; };

    /* 2.1 線分補間（lon,lat,ele） */
    function interpolate(ptA, ptB, t){
      return [
        ptA[0] + t*(ptB[0]-ptA[0]),
        ptA[1] + t*(ptB[1]-ptA[1]),
        ptA[2] + t*(ptB[2]-ptA[2])
      ];
    }

    /* 2.2 直前 N 点分の登り量 [m] */
    function calcAscend(lineCoords, idx, backN = ASCEND_LOOKBACK){
      let ascend = 0;
      const s = Math.max(1, idx - backN + 1);
      for(let i=s; i<=idx; i++){
        const up = lineCoords[i][2] - lineCoords[i-1][2];
        if(up > 0) ascend += up;
      }
      return ascend;  // m
    }

    /* --------------------
       3.  アプリケーション状態
    -------------------- */
    let points = [];          // {lat,lng,name,isPOI?}
    let markers = [], restMarkers = [];
    let routeLayers = [];     // GeoJSON layers
    let routeDistances = [], routeLabels = [];
    let watchId = null, realTimeMarker = null, lastLatLng = null;

    /* --------------------
       4.  マーカー & リスト更新
    -------------------- */
    function addPoint(lat,lng,name=null){
      points.push({lat,lng,name});
      updateMarkers(); refreshPointList();
    }

    function updateMarkers(){
      clearLayers(markers); clearLayers(restMarkers);
      points.forEach((p,i)=>{
        let icon = iconVia;
        if(i===0) icon=iconStart;
        else if(i===points.length-1) icon=iconEnd;
        else if(p.name?.startsWith('休憩')){
          icon = p.isPOI ? iconRest : iconRestG;
        }
        const mk = L.marker([p.lat,p.lng],{icon})
                    .addTo(map)
                    .bindPopup(p.name||`(${p.lat.toFixed(5)},${p.lng.toFixed(5)})`);
        (icon===iconRest||icon===iconRestG ? restMarkers : markers).push(mk);
      });
    }

    function refreshPointList(){
      pointList.innerHTML='';
      points.forEach((p,i)=>{
        const li = document.createElement('li'); li.className='draggable';
        const span = document.createElement('span'); span.className='role-name';
        let prefix;
        if(p.name?.startsWith('休憩')){
          const m=p.name.match(/^休憩(\d+)/);
          prefix = m ? `休憩${m[1]}: ` : '休憩: ';
        } else if(i===0) prefix='出発地: ';
        else if(i===points.length-1) prefix='目的地: ';
        else prefix = `経由地${i}: `;
        span.textContent = prefix + (p.name?.replace(/^休憩\d+:\s?/, '')||`(${p.lat.toFixed(5)}, ${p.lng.toFixed(5)})`);
        const btn=document.createElement('button'); btn.textContent='×';
        btn.onclick=()=>{points.splice(i,1); updateMarkers(); refreshPointList();};
        li.appendChild(span); li.appendChild(btn); pointList.appendChild(li);
      });
    }

    /* Sortable.js ドラッグ並べ替え */
    new Sortable(pointList,{
      animation:150,
      onEnd:()=>{
        const arr=[];
        Array.from(pointList.children).forEach(li=>{
          const txt = li.querySelector('span.role-name').textContent
                       .replace(/^出発地:|^目的地:|^経由地\d+:|^休憩\d+: /,'').trim();
          const m   = points.find(p=>{
            let base = p.name?.replace(/^休憩\d+:\s?/,'')||`(${p.lat.toFixed(5)}, ${p.lng.toFixed(5)})`;
            return base === txt;
          });
          if(m) arr.push(m);
        });
        points=arr; updateMarkers(); refreshPointList();
      }
    });

    /* --------------------
       5.  POI 取得 (LineString + buffer)
    -------------------- */
    async function fetchPoisAlongRoute(lineCoords, buffer=POI_SEARCH_RADIUS, categories=REST_POI_CATEGORIES){
      const body={
        request:'pois',
        geometry:{geojson:{type:'LineString',coordinates:lineCoords}},
        limit:100,
        buffer,
        filters:{category_ids:categories}
      };
      const res = await fetch('https://api.openrouteservice.org/pois',{
        method:'POST',
        headers:{'Content-Type':'application/json','Authorization':apiKey},
        body:JSON.stringify(body)
      });
      if(!res.ok) return [];
      const js = await res.json();
      return js.features.map(f=>({
        lon:f.geometry.coordinates[0],
        lat:f.geometry.coordinates[1],
        catIds:f.properties.category_ids,
        name:f.properties.name||'',
        address:[f.properties.street,f.properties.housenumber,f.properties.locality]
                .filter(Boolean).join(' ')
      }));
    }
    const catLabel = ids=>{
      if(ids.includes(533)) return "コンビニ";
      if(ids.includes(532)) return "スーパー";
      if(ids.includes(414)) return "道の駅";
      return "POI";
    };

    /* --------------------
       6.  休憩自動挿入（高度考慮付き）
    -------------------- */
    async function insertRestStopsByTime(feature){

      const intervalSec = INTERVAL_MIN()*60;      // [s]
      const coords3d = feature.geometry.coordinates; // [lon,lat,ele]
      const steps   = feature.properties.segments[0].steps;

      /* 6.1 累積時間配列 */
      const cumulative=[0];
      steps.forEach(s=>cumulative.push(cumulative.at(-1)+s.duration));

      /* 6.2 休憩ターゲット時刻 */
      const targets=[];
      for(let t=intervalSec; t<cumulative.at(-1); t+=intervalSec) targets.push(t);

      /* 6.3 ルート全体 POI 一括取得 */
      const poisAll = await fetchPoisAlongRoute(coords3d);

      const restPoints=[];
      for(let i=0;i<targets.length;i++){
        const target=targets[i];

        /* a) 線分補間で厳密座標 (lon,lat,ele) */
        let idx = cumulative.findIndex(c=>c>=target);
        if(idx<1) idx=1;
        const ratio = (target - cumulative[idx-1]) / steps[idx].duration;
        const goal   = interpolate(coords3d[idx-1], coords3d[idx], ratio); // [lon,lat,ele]
        const goalLat=goal[1], goalLon=goal[0];

        /* b) 直前登り量 */
        const ascendPrev = calcAscend(coords3d, idx, ASCEND_LOOKBACK);

        /* c) 候補 POI のスコアリング */
        let best=null, bestScore=Infinity;
        for(const p of poisAll){
          const lateral = haversine(goalLat,goalLon,p.lat,p.lon);
          if(lateral>MAX_LATERAL) continue;

          /* 時間ズレ近似: ステップ比 × duration */
          const alongDist = haversine(coords3d[idx-1][1],coords3d[idx-1][0],p.lat,p.lon);
          const timeDiff  = Math.abs(alongDist / steps[idx].distance * steps[idx].duration - ratio*steps[idx].duration);

          const score = W_TIME*timeDiff + W_DIST*lateral + W_ASC*ascendPrev;
          if(score<bestScore){
            best={...p,lateral,timeDiff,ascendPrev}; bestScore=score;
          }
        }

        /* d) 閾値判定 */
        let isPOI = false, label='';
        if(best && best.timeDiff<MAX_TIME_DIFF){
          isPOI = true;
          label = `休憩${i+1}: ${best.name||'施設名なし'}（${catLabel(best.catIds)}）`
                + `（ズレ ${(best.timeDiff/60).toFixed(1)}分 / ${best.lateral.toFixed(0)}m`
                + `｜登り ${best.ascendPrev.toFixed(0)}m）`;
          restPoints.push({lat:best.lat,lng:best.lon,isPOI,name:label});
        }else{
          label = `休憩${i+1}: 仮休憩 [POIなし] [${goalLat.toFixed(5)},${goalLon.toFixed(5)}]`;
          restPoints.push({lat:goalLat,lng:goalLon,isPOI:false,name:label});
        }
        progressStatus.textContent=`休憩地点を評価中… ${i+1}/${targets.length}`;
        await new Promise(r=>setTimeout(r,50));
      }

      /* e) points に挿入 */
      const newPts=[points[0],...restPoints,points.at(-1)];
      points=newPts; updateMarkers(); refreshPointList();
      progressStatus.textContent="休憩地点の追加完了！";
    }

    /* --------------------
       7.  ルート描画（steepness & elevation）
    -------------------- */
    async function drawRouteWithSteep(includeRest=true){
      progressStatus.textContent='';

      if(points.length<2){alert('出発地と目的地を含む2地点以上を登録してください');return;}
      if(points.length>10){alert('登録地点数が多すぎます（10地点まで）');return;}

      /* --- 休憩自動挿入フェーズ --- */
      if(includeRest && restCheckbox.checked){
        const tmpCoords = points.map(p=>[p.lng,p.lat]);
        const tmpRes = await fetch(
          `https://api.openrouteservice.org/v2/directions/${profileSelect.value}/geojson?elevation=true`,
          {method:'POST',headers:{'Content-Type':'application/json','Authorization':apiKey},
           body:JSON.stringify({coordinates:tmpCoords,instructions:true})});
        if(!tmpRes.ok){alert('ルート取得エラー');return;}
        const tmpData = await tmpRes.json();
        if(tmpData?.features?.[0]){
          await insertRestStopsByTime(tmpData.features[0]);
          updateMarkers(); refreshPointList();
        }
      }

      /* --- 本ルート計算 --- */
      const coords = points.map(p=>[p.lng,p.lat]);
      let body;
      if(points.length===2){
        body={coordinates:coords,alternative_routes:{share_factor:0.6,target_count:3},extra_info:["steepness"]};
      }else{
        body={coordinates:coords,extra_info:["steepness"]};
      }
      routeInfo.innerHTML="ルート計算中…";
      const res = await fetch(
        `https://api.openrouteservice.org/v2/directions/${profileSelect.value}/geojson?elevation=true`,
        {method:'POST',headers:{'Content-Type':'application/json','Authorization':apiKey},
         body:JSON.stringify(body)});
      if(!res.ok){alert('ルート取得エラー');return;}
      const data = await res.json();
      if(!data.features?.length){alert('ルート情報が取得できません');return;}

      /* 坂少・坂多比較 */
      let best=data.features[0], worst=data.features[0];
      if(points.length===2 && data.features.length>1){
        const routes=data.features.map(f=>{
          const steep=f.properties.extras.steepness?.values||[];
          let sum=0; steep.forEach(s=>sum+=Math.abs(s[1]));
          return {feature:f, sum};
        });
        best = routes.reduce((a,b)=>a.sum<=b.sum?a:b).feature;
        worst= routes.reduce((a,b)=>a.sum>=b.sum?a:b).feature;
      }

      /* 描画 */
      clearLayers(routeLayers);
      const layerBest = L.geoJSON(best,{style:{color:'#0095ff',weight:6}}).addTo(map);
      let layerWorst=null;
      if(points.length===2 && worst!==best){
        layerWorst=L.geoJSON(worst,{style:{color:'#ff1c1c',weight:5,dashArray:'10 8'}}).addTo(map);
        routeLayers.push(layerBest,layerWorst);
      }else routeLayers.push(layerBest);
      map.fitBounds(layerBest.getBounds());

      /* サマリ */
      const s = best.properties.summary;
      routeInfo.innerHTML=`<b>坂が少ないルート</b>（青）距離 ${(s.distance/1000).toFixed(2)}km /
        ${(s.duration/60).toFixed(1)}分
        ${points.length===2&&worst!==best?`<br><b>坂が多いルート</b>（赤）距離 ${(worst.properties.summary.distance/1000).toFixed(2)}km /
        ${(worst.properties.summary.duration/60).toFixed(1)}分`:''}`;

      /* グラフ用 */
      routeDistances=[]; routeLabels=[];
      const coordsArr = best.geometry.coordinates.map(p=>({lat:p[1],lng:p[0]}));
      for(let i=1;i<coordsArr.length;i++){
        routeDistances.push(haversine(coordsArr[i-1].lat,coordsArr[i-1].lng,coordsArr[i].lat,coordsArr[i].lng));
        routeLabels.push([`P${i}`,`P${i+1}`]);
      }
      showChart();
      progressStatus.textContent='';
    }

    /* --------------------
       8.  Chart.js
    -------------------- */
    function showChart(){
      $('distanceChartContainer').style.display='block';
      const ctx=$('distanceChart').getContext('2d');
      if(window.distanceChart) window.distanceChart.destroy();
      window.distanceChart=new Chart(ctx,{
        type:'bar',
        data:{
          labels:routeLabels.map((l,i)=>`区間${i+1} (${l[0]}→${l[1]})`),
          datasets:[{label:'距離(km)',data:routeDistances.map(d=>(d/1000).toFixed(2)),
                     backgroundColor:'rgba(75,192,192,0.6)'}]},
        options:{responsive:true,plugins:{legend:{display:true}},
                 scales:{y:{title:{display:true,text:'距離 (km)'}}}}
      });
    }

    /* --------------------
       9.  DL系
    -------------------- */
    function downloadCsv(){
      if(!routeDistances.length){alert('ルートが表示されていません');return;}
      const avg = routeDistances.reduce((a,b)=>a+b,0)/routeDistances.length;
      const mse = routeDistances.reduce((s,d)=>s+(d-avg)**2,0)/routeDistances.length;
      let csv = '\uFEFF出発地,目的地,区間距離(km),平均距離(km),MSE\n';
      routeDistances.forEach((d,i)=>{
        csv += `${routeLabels[i][0]},${routeLabels[i][1]},${(d/1000).toFixed(2)},${(avg/1000).toFixed(2)},${(mse/1_000_000).toFixed(4)}\n`;
      });
      const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url;
      a.download=`ルートスコア_${new Date().toISOString().slice(0,10)}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    }
    function downloadGraph(){
      if(!window.distanceChart){alert('グラフがまだ表示されていません');return;}
      const c=$('distanceChart'); const tmp=document.createElement('canvas');
      tmp.width=c.width; tmp.height=c.height;
      const ctx=tmp.getContext('2d'); ctx.fillStyle='#fff';
      ctx.fillRect(0,0,tmp.width,tmp.height); ctx.drawImage(c,0,0);
      const a=document.createElement('a'); a.href=tmp.toDataURL('image/png');
      a.download=`距離分布_${new Date().toISOString().slice(0,10)}.png`;
      document.body.appendChild(a); a.click(); a.remove();
    }

    /* --------------------
       10.  ジオコーディング UI
    -------------------- */
    function fetchPlaces(url){
      fetch(url).then(r=>r.json()).then(d=>{
        searchResults.innerHTML='';
        if(!d.length){searchResults.textContent='該当なし';return;}
        d.forEach(p=>{
          const li=document.createElement('li');
          li.textContent=p.display_name;
          li.onclick=()=>{addPoint(+p.lat,+p.lon,p.display_name); placeInput.value=''; searchResults.innerHTML='';};
          searchResults.appendChild(li);
        });
      }).catch(e=>searchResults.textContent='検索エラー: '+e.message);
    }
    function fetchNearbyPlaces(q){
      let url=`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=10&addressdetails=1`;
      if(nearBox.checked && navigator.geolocation){
        navigator.geolocation.getCurrentPosition(pos=>{
          const {latitude:lat,longitude:lon}=pos.coords;
          const d=0.05;
          url+=`&viewbox=${lon-d},${lat+d},${lon+d},${lat-d}&bounded=1`;
          fetchPlaces(url);
        });
      }else fetchPlaces(url);
    }

    /* --------------------
       11.  ボタンイベント
    -------------------- */
    $('searchPlaceBtn').onclick = ()=>{const q=placeInput.value.trim(); if(q)fetchNearbyPlaces(q);};
    $('clearPlaceInputBtn').onclick=()=>{placeInput.value=''; searchResults.innerHTML='';};
    $('addCurrentBtn').onclick  = ()=>{
      if(!navigator.geolocation){alert('現在地取得未対応');return;}
      navigator.geolocation.getCurrentPosition(p=>addPoint(p.coords.latitude,p.coords.longitude,'現在地'));
    };

    $('toggleRealTimeBtn').onclick=()=>{
      const btn=$('toggleRealTimeBtn');
      if(watchId){
        navigator.geolocation.clearWatch(watchId); watchId=null;
        if(realTimeMarker) map.removeLayer(realTimeMarker);
        btn.textContent='リアルタイム現在地更新 OFF';
        return;
      }
      if(!navigator.geolocation){alert('現在地取得未対応');return;}
      watchId=navigator.geolocation.watchPosition(pos=>{
        const {latitude:lat,longitude:lon}=pos.coords;
        if(!realTimeMarker){
          realTimeMarker=L.marker([lat,lon]).addTo(map).bindPopup('リアルタイム現在地');
          addPoint(lat,lon,'リアルタイム現在地');
        }else realTimeMarker.setLatLng([lat,lon]);
        map.setView([lat,lon],14);
        if(lastLatLng){
          const d=haversine(lastLatLng.lat,lastLatLng.lng,lat,lon);
          if(d>=AUTO_REDRAW_DISTANCE) drawRouteWithSteep();
        }
        lastLatLng={lat,lng:lon};
      },err=>alert('リアルタイム位置取得失敗: '+err.message),
      {enableHighAccuracy:true,maximumAge:1000,timeout:10000});
      btn.textContent='リアルタイム現在地更新 ON';
    };

    $('drawRouteBtn').onclick  = ()=>drawRouteWithSteep();
    $('downloadCsvBtn').onclick=downloadCsv;
    $('downloadGraphBtn').onclick=downloadGraph;
  </script>
</body>
</html>
