<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>等間隔休憩 + 標高考慮ルート案内（距離/時間切替版）</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  #map{height:500px;}
  #controls{margin:10px 0;display:flex;flex-wrap:wrap;gap:6px;align-items:center;}
  #searchResults{max-height:150px;overflow-y:auto;list-style:none;border:1px solid #ccc;}
  #searchResults li:hover{background:#eee;cursor:pointer;}
  #pointList{list-style:none;padding:0;}
  #pointList li{padding:4px;border:1px solid #ccc;margin-bottom:4px;background:#fafafa;cursor:move;display:flex;justify-content:space-between;align-items:center;}
  #pointList li span.role-name{flex-grow:1;}
  #distanceChartContainer{display:none;margin-top:20px;background:#fff;padding:10px;}
  #progressStatus{margin:6px 0;color:#ff9900;font-weight:bold;min-height:1.5em;}
  .legend-steep{display:inline-block;border-radius:8px;padding:2px 10px;margin-right:10px;}
  .legend-blue{background:#6ab4ff;color:#003366;}
  .legend-red{background:#ffaaa2;color:#7a001b;}
  .legend-orange{background:#ffd966;color:#a87d00;}
  .legend-gray{background:#bcbcbc;color:#333;}
</style>
</head>
<body style="background:#fff;">

<h2>等間隔休憩 + 標高考慮ルート案内（距離/時間切替版）</h2>

<!-- ---------- 操作パネル ---------- -->
<div id="controls">
  <input id="placeInput" type="text" placeholder="地名・住所を入力" style="width:240px;">
  <button id="clearPlaceInputBtn">×</button>
  <button id="searchPlaceBtn">地名検索</button>
  <label><input type="checkbox" id="nearbyOnlyCheckbox"> 近くの場所のみ検索</label>
  <button id="addCurrentBtn">現在地を追加</button>
  <button id="toggleRealTimeBtn">リアルタイム現在地更新 OFF</button>
  <button id="drawRouteBtn">坂ルート表示</button>

  <!-- 休憩条件：時間 or 距離 -->
  <label style="display:flex;align-items:center;gap:4px;">
    <input type="checkbox" id="restCheckbox">
    <input type="number" id="restTimeInput" value="60" min="1" style="width:60px;" disabled> 分ごと
  </label>
  <label style="display:flex;align-items:center;gap:4px;">
    <input type="checkbox" id="distanceModeCheckbox"> 距離基準
    <input type="number" id="restDistInput" value="2" min="0.1" step="0.1" style="width:60px;" disabled> km ごと
  </label>

  <button id="downloadCsvBtn">スコアCSV</button>
  <button id="downloadGraphBtn">距離グラフ</button>

  <select id="profileSelect">
    <option value="foot-walking">徒歩</option>
    <option value="driving-car">車</option>
    <option value="cycling-regular">自転車（一般）</option>
    <option value="cycling-road" selected>ロードバイク</option>
    <option value="cycling-mountain">マウンテンバイク</option>
    <option value="cycling-electric">E-Bike</option>
  </select>
  <div id="routeInfo" style="margin-left:8px;"></div>
</div>

<!-- 凡例 -->
<div>
  <span class="legend-steep legend-blue">青：坂が少</span>
  <span class="legend-steep legend-red">赤：坂が多</span>
  <span class="legend-steep legend-orange">黄：POI休憩</span>
  <span class="legend-steep legend-gray">灰：仮休憩</span>
</div>

<div id="progressStatus"></div>
<h3>登録地点リスト（ドラッグで並び替え可）</h3>
<ul id="pointList"></ul>
<ul id="searchResults"></ul>
<div id="map"></div>

<!-- 距離グラフ -->
<div id="distanceChartContainer">
  <canvas id="distanceChart" width="800" height="400" style="background:#fff;"></canvas>
</div>

<!-- ---------- ライブラリ ---------- -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/sortablejs@latest/Sortable.min.js"></script>

<script>
/* ===============================================
   0. グローバル定数とパラメータ
================================================ */
const apiKey              = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9';  // ←★自分の ORS API キー
const AUTO_REDRAW_DISTANCE= 50;              // [m] リアルタイム更新再計算距離
const POI_BUFFER_M        = 800;             // [m] ルート→POI 検索バッファ
const REST_POI_CATEGORIES = [533,532,414];   // コンビニ/スーパー/道の駅

/* 重み & 閾値（好みで調整可） */
const MAX_LATERAL_M   = 200;   // POI 横距離しきい
const W_TIME          = 3;     // timeDiff 重み
const W_DIST          = 1;     // lateralDist 重み
const W_ASC           = -1;    // ascendPrev 重み（負: 登坂後優遇）
const ASC_LOOKBACK    = 5;     // 直前N頂点で登り量計算

/* 時間/距離入力の有効化 */
restCheckbox.onchange      = ()=>{restTimeInput.disabled = !restCheckbox.checked;};
distanceModeCheckbox.onchange = ()=>{
  restDistInput.disabled = !distanceModeCheckbox.checked;
  restCheckbox.checked = !distanceModeCheckbox.checked;
  restTimeInput.disabled = !restCheckbox.checked;
};

/* ===============================================
   1. Leaflet 初期化
================================================ */
const map = L.map('map').setView([35.681236,139.767125],13);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  {attribution:'&copy; OpenStreetMap contributors'}).addTo(map);

/* アイコン */
const iconStart  = new L.Icon({iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png',  iconSize:[32,32],iconAnchor:[16,32]});
const iconVia    = new L.Icon({iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/blue-dot.png',   iconSize:[32,32],iconAnchor:[16,32]});
const iconEnd    = new L.Icon({iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/red-dot.png',    iconSize:[32,32],iconAnchor:[16,32]});
const iconRest   = new L.Icon({iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/orange-dot.png', iconSize:[32,32],iconAnchor:[16,32]});
const iconRestG  = new L.Icon({iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/ltgray-dot.png', iconSize:[32,32],iconAnchor:[16,32]});

/* ===============================================
   2. 汎用関数
================================================ */
const $ = id=>document.getElementById(id);
const toRad = d=>d*Math.PI/180;
const haversine = (lat1,lon1,lat2,lon2)=>{
  const R=6371000;
  const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
  const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
};
const clearLayers = arr=>{arr.forEach(l=>map.removeLayer(l));arr.length=0;};

/* 線分補間 */
function interp(ptA,ptB,t){return[
  ptA[0]+t*(ptB[0]-ptA[0]),
  ptA[1]+t*(ptB[1]-ptA[1]),
  ptA[2]+t*(ptB[2]-ptA[2])
];}
/* 直前登り量 */
function ascendPrev(coords,idx,n=ASC_LOOKBACK){
  let asc=0;
  const s=Math.max(1,idx-n+1);
  for(let i=s;i<=idx;i++){
    const up=coords[i][2]-coords[i-1][2];
    if(up>0) asc+=up;
  }
  return asc;
}
/* POI カテゴリ名 */
const catLabel=ids=>{
  if(ids.includes(533))return'コンビニ';
  if(ids.includes(532))return'スーパー';
  if(ids.includes(414))return'道の駅';
  return'POI';
};

/* ===============================================
   3. アプリケーション状態
================================================ */
let points=[],markers=[],restMarkers=[],routeLayers=[];
let routeDistances=[],routeLabels=[];
let watchId=null,realTimeMarker=null,lastLatLng=null;

/* ===============================================
   4. マーカー／リスト描画
================================================ */
function addPoint(lat,lng,name=null){
  points.push({lat,lng,name});
  updateMarkers();refreshPointList();
}
function updateMarkers(){
  clearLayers(markers);clearLayers(restMarkers);
  points.forEach((p,i)=>{
    let icon=iconVia;
    if(i===0)icon=iconStart;
    else if(i===points.length-1)icon=iconEnd;
    else if(p.name?.startsWith('休憩'))icon=p.isPOI?iconRest:iconRestG;
    const m=L.marker([p.lat,p.lng],{icon}).addTo(map)
            .bindPopup(p.name||`(${p.lat.toFixed(5)},${p.lng.toFixed(5)})`);
    (icon===iconRest||icon===iconRestG?restMarkers:markers).push(m);
  });
}
function refreshPointList(){
  pointList.innerHTML='';
  points.forEach((p,i)=>{
    const li=document.createElement('li');li.className='draggable';
    const sp=document.createElement('span');sp.className='role-name';
    let prefix;
    if(p.name?.startsWith('休憩')){
      const m=p.name.match(/^休憩(\d+)/);prefix=m?`休憩${m[1]}: `:'休憩: ';
    }else if(i===0)prefix='出発地: ';
    else if(i===points.length-1)prefix='目的地: ';
    else prefix=`経由地${i}: `;
    sp.textContent=prefix+(p.name?.replace(/^休憩\d+:\s?/,'')||`(${p.lat.toFixed(5)},${p.lng.toFixed(5)})`);
    const btn=document.createElement('button');btn.textContent='×';
    btn.onclick=()=>{points.splice(i,1);updateMarkers();refreshPointList();};
    li.appendChild(sp);li.appendChild(btn);pointList.appendChild(li);
  });
}
new Sortable(pointList,{animation:150,onEnd:()=>{
  const arr=[];
  [...pointList.children].forEach(li=>{
    const txt=li.querySelector('span.role-name').textContent
      .replace(/^出発地:|^目的地:|^経由地\d+:|^休憩\d+: /,'').trim();
    const m=points.find(p=>{
      const base=p.name?.replace(/^休憩\d+:\s?/,'')||`(${p.lat.toFixed(5)}, ${p.lng.toFixed(5)})`;
      return base===txt;
    });
    if(m)arr.push(m);
  });
  points=arr;updateMarkers();refreshPointList();
}});

/* ===============================================
   5. POI 取得
================================================ */
async function fetchPois(lineCoords,buffer=POI_BUFFER_M,cats=REST_POI_CATEGORIES){
  const body={
    request:'pois',
    geometry:{geojson:{type:'LineString',coordinates:lineCoords}},
    buffer,limit:100,filters:{category_ids:cats}
  };
  const res=await fetch('https://api.openrouteservice.org/pois',{
    method:'POST',headers:{'Content-Type':'application/json','Authorization':apiKey},
    body:JSON.stringify(body)
  });
  if(!res.ok)return[];
  const js=await res.json();
  return js.features.map(f=>({
    id:f.id||`${f.geometry.coordinates[0]}_${f.geometry.coordinates[1]}`,
    lon:f.geometry.coordinates[0],
    lat:f.geometry.coordinates[1],
    catIds:f.properties.category_ids||[],
    name:f.properties.name||'',
    address:[f.properties.street,f.properties.housenumber,f.properties.locality].filter(Boolean).join(' ')
  }));
}

/* ===============================================
   6. 休憩自動挿入（時間/距離両対応）
================================================ */
async function insertRestStops(feature){
  const coords3d=feature.geometry.coordinates;       // [lon,lat,ele]
  const steps   =feature.properties.segments[0].steps;

  /* 6.1 累積距離＆時間 */
  const cumTime=[0],cumDist=[0];
  steps.forEach((s,idx)=>{
    cumTime.push(cumTime.at(-1)+s.duration);
    /* 累積距離は座標から計算 */
    const d=haversine(coords3d[idx][1],coords3d[idx][0],
                      coords3d[idx+1][1],coords3d[idx+1][0]);
    cumDist.push(cumDist.at(-1)+d);
  });

  /* 6.2 ターゲット生成 */
  const targets=[];            // 要素は {type:'time'|'dist',value:seconds|meters}
  if(distanceModeCheckbox.checked){        // 距離基準
    const intM=Number(restDistInput.value||2)*1000;
    for(let d=intM;d<cumDist.at(-1);d+=intM)targets.push({type:'dist',value:d});
  }else{                                     // 時間基準
    const intS=Number(restTimeInput.value||60)*60;
    for(let t=intS;t<cumTime.at(-1);t+=intS)targets.push({type:'time',value:t});
  }
  if(!targets.length)return 0;

  /* 6.3 ルート全体 POI 取得 */
  const poisAll=await fetchPois(coords3d);

  /* 6.4 スコアリング */
  const restPts=[],usedIds=new Set();
  for(let i=0;i<targets.length;i++){
    const tgt=targets[i];
    let idx,ratio;
    if(tgt.type==='time'){
      idx=cumTime.findIndex(c=>c>=tgt.value);if(idx<1)idx=1;
      ratio=(tgt.value-cumTime[idx-1])/(cumTime[idx]-cumTime[idx-1]);
    }else{
      idx=cumDist.findIndex(c=>c>=tgt.value);if(idx<1)idx=1;
      ratio=(tgt.value-cumDist[idx-1])/(cumDist[idx]-cumDist[idx-1]);
    }
    const goal=interp(coords3d[idx-1],coords3d[idx],ratio);
    const goalLat=goal[1],goalLon=goal[0];
    const asc=ascendPrev(coords3d,idx);

    let best=null,bestScore=Infinity;
    const maxTimeDiff=(distanceModeCheckbox.checked?Number(restDistInput.value)*60: Number(restTimeInput.value)*60)*0.4;
    for(const p of poisAll){
      if(usedIds.has(p.id))continue;
      const lateral=haversine(goalLat,goalLon,p.lat,p.lon);
      if(lateral>MAX_LATERAL_M)continue;
      /* timeDiff 近似 */
      const along=haversine(coords3d[idx-1][1],coords3d[idx-1][0],p.lat,p.lon);
      const segDist=haversine(coords3d[idx-1][1],coords3d[idx-1][0],coords3d[idx][1],coords3d[idx][0]);
      const segTime=cumTime[idx]-cumTime[idx-1];
      const timeDiff=Math.abs(along/segDist*segTime - ratio*segTime);

      if(timeDiff>maxTimeDiff)continue;

      const score=W_TIME*timeDiff+W_DIST*lateral+W_ASC*asc;
      if(score<bestScore){
        best={...p,lateral,timeDiff,asc};bestScore=score;
      }
    }

    let label,isPOI=false;
    if(best){
      isPOI=true;usedIds.add(best.id);
      label=`休憩${i+1}: ${best.name||'施設名なし'}（${catLabel(best.catIds)}）`
          +`（ズレ ${(best.timeDiff/60).toFixed(1)}分/${best.lateral.toFixed(0)}m｜登り ${best.asc.toFixed(0)}m）`;
      restPts.push({lat:best.lat,lng:best.lon,isPOI,name:label});
    }else{
      label=`休憩${i+1}: 仮休憩 [${goalLat.toFixed(5)},${goalLon.toFixed(5)}]`;
      restPts.push({lat:goalLat,lng:goalLon,isPOI:false,name:label});
    }
    progressStatus.textContent=`休憩地点計算中… ${i+1}/${targets.length}`;
    await new Promise(r=>setTimeout(r,40));
  }

  /* 6.5 points に挿入 */
  points=[points[0],...restPts,points.at(-1)];
  updateMarkers();refreshPointList();
  progressStatus.textContent="休憩地点追加完了";
  return restPts.length;
}

/* ===============================================
   7. ルート計算 & 描画
================================================ */
async function drawRoute(includeRest=true){
  progressStatus.textContent='';
  if(points.length<2){alert('2地点以上登録してください');return;}
  if(points.length>10){alert('地点は10個まで');return;}

  /* 休憩自動挿入フェーズ */
  if(includeRest && (restCheckbox.checked||distanceModeCheckbox.checked)){
    const tmpCoords=points.map(p=>[p.lng,p.lat]);
    const r=await fetch(
      `https://api.openrouteservice.org/v2/directions/${profileSelect.value}/geojson?elevation=true`,
      {method:'POST',headers:{'Content-Type':'application/json','Authorization':apiKey},
       body:JSON.stringify({coordinates:tmpCoords,instructions:true})}
    );
    if(!r.ok){alert('ルート取得失敗');return;}
    const data=await r.json();
    if(data.features?.[0])await insertRestStops(data.features[0]);
  }

  /* 本ルート計算 */
  const coords=points.map(p=>[p.lng,p.lat]);
  const body=points.length===2
    ?{coordinates:coords,alternative_routes:{share_factor:0.6,target_count:3},extra_info:["steepness"]}
    :{coordinates:coords,extra_info:["steepness"]};
  routeInfo.innerHTML='ルート計算中…';
  const res=await fetch(
    `https://api.openrouteservice.org/v2/directions/${profileSelect.value}/geojson?elevation=true`,
    {method:'POST',headers:{'Content-Type':'application/json','Authorization':apiKey},body:JSON.stringify(body)}
  );
  if(!res.ok){alert('ルート取得失敗');return;}
  const js=await res.json();
  if(!js.features?.length){alert('ルート無し');return;}

  /* 坂比較 */
  let best=js.features[0],worst=js.features[0];
  if(points.length===2 && js.features.length>1){
    const arr=js.features.map(f=>{
      const v=f.properties.extras.steepness?.values||[];let s=0;v.forEach(x=>s+=Math.abs(x[1]));
      return {f, s};
    });
    best=arr.reduce((a,b)=>a.s<=b.s?a:b).f;
    worst=arr.reduce((a,b)=>a.s>=b.s?a:b).f;
  }

  clearLayers(routeLayers);
  const lBest=L.geoJSON(best,{style:{color:'#0095ff',weight:6}}).addTo(map);
  if(points.length===2&&worst!==best){
    const lWorst=L.geoJSON(worst,{style:{color:'#ff1c1c',weight:5,dashArray:'10 8'}}).addTo(map);
    routeLayers.push(lBest,lWorst);
  }else routeLayers.push(lBest);
  map.fitBounds(lBest.getBounds());

  const s=best.properties.summary;
  routeInfo.innerHTML=
    `<b>坂少</b> ${ (s.distance/1000).toFixed(2)}km / ${(s.duration/60).toFixed(1)}分`
    +(points.length===2&&worst!==best?`<br><b>坂多</b> ${(worst.properties.summary.distance/1000).toFixed(2)}km / ${(worst.properties.summary.duration/60).toFixed(1)}分`:'');
  
  /* グラフデータ更新 */
  routeDistances=[];routeLabels=[];
  const cs=best.geometry.coordinates.map(c=>({lat:c[1],lng:c[0]}));
  for(let i=1;i<cs.length;i++){
    routeDistances.push(haversine(cs[i-1].lat,cs[i-1].lng,cs[i].lat,cs[i].lng));
    routeLabels.push([`P${i}`,`P${i+1}`]);
  }
  showChart();
}

/* ===============================================
   8. Chart.js
================================================ */
function showChart(){
  distanceChartContainer.style.display='block';
  const ctx=distanceChart.getContext('2d');
  if(window.distanceChart)window.distanceChart.destroy();
  window.distanceChart=new Chart(ctx,{type:'bar',data:{
    labels:routeLabels.map((l,i)=>`区間${i+1} (${l[0]}→${l[1]})`),
    datasets:[{label:'距離(km)',data:routeDistances.map(d=>(d/1000).toFixed(2)),backgroundColor:'rgba(75,192,192,0.6)'}]
  },options:{responsive:true,plugins:{legend:{display:true}},scales:{y:{title:{display:true,text:'距離 (km)'}}}}});
}

/* ===============================================
   9. DL系
================================================ */
downloadCsvBtn.onclick=()=>{
  if(!routeDistances.length){alert('ルート未計算');return;}
  const avg=routeDistances.reduce((a,b)=>a+b,0)/routeDistances.length;
  const mse=routeDistances.reduce((s,d)=>s+(d-avg)**2,0)/routeDistances.length;
  let csv='\uFEFF出発地,目的地,区間距離(km),平均距離(km),MSE\n';
  routeDistances.forEach((d,i)=>csv+=`${routeLabels[i][0]},${routeLabels[i][1]},${(d/1000).toFixed(2)},${(avg/1000).toFixed(2)},${(mse/1_000_000).toFixed(4)}\n`);
  const blob=new Blob([csv],{type:'text/csv'}),url=URL.createObjectURL(blob);
  const a=document.createElement('a');a.href=url;a.download=`ルートスコア_${new Date().toISOString().slice(0,10)}.csv`;a.click();URL.revokeObjectURL(url);
};
downloadGraphBtn.onclick=()=>{
  if(!window.distanceChart){alert('グラフ未表示');return;}
  const c=distanceChart,tmp=document.createElement('canvas');
  tmp.width=c.width;tmp.height=c.height;
  const ctx=tmp.getContext('2d');ctx.fillStyle='#fff';ctx.fillRect(0,0,tmp.width,tmp.height);ctx.drawImage(c,0,0);
  const a=document.createElement('a');a.href=tmp.toDataURL('image/png');a.download=`距離分布_${new Date().toISOString().slice(0,10)}.png`;a.click();
};

/* ===============================================
   10. ジオコーディング UI
================================================ */
function fetchPlaces(url){
  fetch(url).then(r=>r.json()).then(d=>{
    searchResults.innerHTML='';
    if(!d.length){searchResults.textContent='該当なし';return;}
    d.forEach(p=>{
      const li=document.createElement('li');li.textContent=p.display_name;
      li.onclick=()=>{addPoint(+p.lat,+p.lon,p.display_name);placeInput.value='';searchResults.innerHTML='';};
      searchResults.appendChild(li);
    });
  }).catch(e=>searchResults.textContent='検索エラー:'+e.message);
}
searchPlaceBtn.onclick=()=>{
  const q=placeInput.value.trim();if(!q)return;
  let url=`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&limit=10&addressdetails=1`;
  if(nearbyOnlyCheckbox.checked&&navigator.geolocation){
    navigator.geolocation.getCurrentPosition(pos=>{
      const {latitude:lat,longitude:lon}=pos.coords,d=0.05;
      url+=`&viewbox=${lon-d},${lat+d},${lon+d},${lat-d}&bounded=1`;fetchPlaces(url);
    });
  }else fetchPlaces(url);
};
clearPlaceInputBtn.onclick=()=>{placeInput.value='';searchResults.innerHTML='';};

/* ===============================================
   11. 位置系ボタン
================================================ */
addCurrentBtn.onclick=()=>{
  if(!navigator.geolocation){alert('未対応');return;}
  navigator.geolocation.getCurrentPosition(p=>addPoint(p.coords.latitude,p.coords.longitude,'現在地'));
};
toggleRealTimeBtn.onclick=()=>{
  if(watchId){
    navigator.geolocation.clearWatch(watchId);watchId=null;
    if(realTimeMarker)map.removeLayer(realTimeMarker);
    toggleRealTimeBtn.textContent='リアルタイム現在地更新 OFF';return;
  }
  if(!navigator.geolocation){alert('未対応');return;}
  watchId=navigator.geolocation.watchPosition(pos=>{
    const {latitude:lat,longitude:lon}=pos.coords;
    if(!realTimeMarker){
      realTimeMarker=L.marker([lat,lon]).addTo(map).bindPopup('リアルタイム現在地');
      addPoint(lat,lon,'リアルタイム現在地');
    }else realTimeMarker.setLatLng([lat,lon]);
    map.setView([lat,lon],14);
    if(lastLatLng){
      const d=haversine(lastLatLng.lat,lastLatLng.lng,lat,lon);
      if(d>=AUTO_REDRAW_DISTANCE)drawRoute(false);
    }
    lastLatLng={lat,lng:lon};
  },e=>alert('位置取得失敗:'+e.message),{enableHighAccuracy:true,maximumAge:1000,timeout:10000});
  toggleRealTimeBtn.textContent='リアルタイム現在地更新 ON';
};

/* ===============================================
   12. 実行ボタン
================================================ */
drawRouteBtn.onclick =()=>drawRoute();
</script>
</body>
</html>
