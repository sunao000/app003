<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>自転車ルート比較＋休憩（候補3×各モード提案＆選択） v6.1</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>

<style>
body{margin:0;font-family:system-ui,sans-serif}
#map{height:520px;width:100%}
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:8px}
#pointList li{display:flex;flex-wrap:wrap;align-items:flex-start;justify-content:space-between;padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
.small{font-size:.88em;color:#555}
.badge{display:inline-block;padding:1px 6px;border-radius:999px;background:#eef;border:1px solid #cdd;font-size:.8em}
.klist{display:grid;gap:6px}
.kcard{border:1px solid #ddd;border-radius:8px;padding:8px}
.kcard h4{margin:0 0 6px 0;font-size:1rem}
.kcard .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
label.chk{display:inline-flex;align-items:center;gap:6px;margin-right:10px}
</style>
</head>
<body>

<div id="controls">
  <input id="placeInput" placeholder="地名・住所" style="width:260px">
  <button id="addBtn">追加</button>
  <button id="locBtn">現在地</button>
  <button id="drawBtn">ルート表示</button>
  <label class="chk"><input type="checkbox" id="showShortest" checked>最短</label>
  <label class="chk"><input type="checkbox" id="showFastest" checked>最速</label>
</div>

<ul id="pointList"></ul>
<div id="map"></div>

<div class="section">
  <details open>
    <summary>休憩候補の組合せ（<span class="badge">各モード上位3</span>）を計算＆適用</summary>
    <div class="small">※表示ルートは「最短」「最速」のみ。各休憩トリガー周辺のPOIから近い順に最大3件を候補化し、平均/分散ベースのコストで上位3組合せを提示します。</div>
    <div style="margin:8px 0;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="btnCollectCands">休憩候補を収集</button>
      <button id="btnSolveBoth" disabled>最短/最速の候補を計算</button>
      <span id="optStatus" class="small"></span>
    </div>
    <div class="klist">
      <div class="kcard" id="cardShortest">
        <h4>最短モードの上位3組合せ</h4>
        <div id="listShortest" class="klist"></div>
      </div>
      <div class="kcard" id="cardFastest">
        <h4>最速モードの上位3組合せ</h4>
        <div id="listFastest" class="klist"></div>
      </div>
    </div>
  </details>
</div>

<script>
/* ====== 設定 ====== */
const ORS_KEY='5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9'; // ←★あなたの ORS API キーを入れてください
const ORS_ROOT='https://api.openrouteservice.org';

/* ====== ヘルパ ====== */
function $(id){return document.getElementById(id);} 
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
function icon(c){return new L.Icon({iconUrl:'https://maps.gstatic.com/mapfiles/ms2/micons/'+c+'-dot.png',iconSize:[32,32],iconAnchor:[16,32]});}
const ICONS={start:icon('green'),via:icon('blue'),goal:icon('red')};
function safe(path,fb){try{const v=path();return (v===undefined||v===null)?fb:v;}catch(e){return fb;}}
function mean(a){return a.length?a.reduce((x,y)=>x+y,0)/a.length:0;}
function variance(a){if(!a.length) return 0; const m=mean(a); return a.reduce((s,x)=>s+(x-m)*(x-m),0)/a.length;}

/* ====== 状態 ====== */
let map, markerLayer, routeLayers={};
let pts=[]; // {name,lat,lon,type:start/via/goal, isRest?, restCandidates?[]}
let lastDirTs=0;
const pairCache=new Map();

/* ====== 初期化 ====== */
window.addEventListener('DOMContentLoaded',()=>{
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'©OpenStreetMap'}).addTo(map);
  map.createPane('routeShortest').style.zIndex=700;
  map.createPane('routeFastest').style.zIndex=710;

  $('addBtn').onclick=addBySearch;
  $('locBtn').onclick=addCurrent;
  $('drawBtn').onclick=drawRoutes;

  $('btnCollectCands').onclick=async()=>{
    $('optStatus').textContent='休憩トリガ生成＆候補収集中...';
    await ensureRests();             // 休憩トリガ生成（kJしきい値）
    await buildRestCandidatesForAll(); // 各休憩の近い順3件
    $('optStatus').textContent='候補OK。計算できます。';
    $('btnSolveBoth').disabled=false;
  };
  $('btnSolveBoth').onclick=solveBothModes;

  initList();

  // デモ用：2点だけ置いておく
  pts=[{name:'出発',lat:34.07,lon:134.55,type:'start'},{name:'到着',lat:34.15,lon:134.60,type:'goal'}];
  drawList();
});

/* ====== UI: 地点追加 ====== */
async function addBySearch(){
  const q=$('placeInput').value.trim(); if(!q) return;
  const url='https://nominatim.openstreetmap.org/search?format=json&limit=1&q='+encodeURIComponent(q);
  const arr=await (await fetch(url)).json();
  if(!arr.length) return alert('見つかりませんでした');
  const o=arr[0];
  addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});
  $('placeInput').value='';
}
function addCurrent(){navigator.geolocation.getCurrentPosition(p=>addPoint({name:'現在地',lat:p.coords.latitude,lon:p.coords.longitude}),()=>alert('現在地取得失敗'));}
function addPoint(p){p.type=pts.length?'via':'start'; pts.forEach(d=>{if(d.type==='goal') d.type='via';}); pts.push(p); if(pts.length>1) pts[pts.length-1].type='goal'; drawList();}
function fixType(){ if(pts[0]) pts[0].type='start'; if(pts.length>1) pts[pts.length-1].type='goal'; }
function initList(){ new Sortable($('pointList'),{animation:150,handle:'span',onEnd:()=>{pts=Array.from($('pointList').children).map(li=>pts[li._idx]); fixType(); drawList();}}); }
function drawList(){
  const ul=$('pointList'); ul.innerHTML='';
  pts.forEach((p,i)=>{
    const li=document.createElement('li'); li._idx=i;
    const t=document.createElement('span'); t.textContent=p.name+(p.isRest?'（休憩）':''); li.appendChild(t);
    const del=document.createElement('button'); del.className='del'; del.textContent='×';
    del.onclick=(e)=>{e.stopPropagation(); pts.splice(i,1); fixType(); drawList();}; li.appendChild(del);

    // 休憩候補表示（あれば）
    if(p.isRest && Array.isArray(p.restCandidates) && p.restCandidates.length){
      const det=document.createElement('details');
      const sum=document.createElement('summary'); sum.textContent=`候補（${p.restCandidates.length}件）`; det.appendChild(sum);
      const ul2=document.createElement('ul'); ul2.style.margin='6px 0 0 16px';
      p.restCandidates.forEach((c,idx)=>{ const li2=document.createElement('li'); li2.textContent=`#${idx+1} ${c.name||'POI'} / ${(c._d||0).toFixed(0)}m`; ul2.appendChild(li2);});
      det.appendChild(ul2); li.appendChild(det);
    }
    ul.appendChild(li);
  });
}

/* ====== ORS ====== */
async function post(url,body){
  const r=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json','Authorization':ORS_KEY},body:JSON.stringify(body)});
  if(!r.ok) throw new Error(r.status);
  return r.json();
}
async function dir(body,profile){
  const wait=1100-(Date.now()-lastDirTs);
  if(wait>0) await sleep(wait);
  const d=await post(ORS_ROOT+'/v2/directions/'+profile+'/geojson',body);
  lastDirTs=Date.now();
  return d;
}

/* ====== エネルギー（簡易） ====== */
function energyStepKJ(d,dz,m,flat){return flat*(d/1000)+Math.max(dz,0)*m*9.80665/1000;}

/* ====== 休憩トリガ（kJしきい値シンプル版） ====== */
function buildCumDistArray(coords){
  const cd=[0];
  for(let i=1;i<coords.length;i++){
    const [lon,lat]=coords[i]; const [plon,plat]=coords[i-1];
    cd[i]=cd[i-1]+L.latLng(lat,lon).distanceTo([plat,plon]);
  }
  return cd;
}
async function makeRestSimple(previewFeature,mass,flat,thrKJ){
  const coords=previewFeature.geometry.coordinates;
  const segs=safe(()=>previewFeature.properties.segments,[])||[];
  const hasEle=(coords[0].length>=3);
  const cum=buildCumDistArray(coords);
  let acc=0; const out=[];
  for(const s of segs){
    const steps=s.steps||[];
    for(const st of steps){
      const [i0,i1]=st.way_points||[0,0];
      const d=st.distance||0;
      const dz=hasEle?((coords[i1][2]||0)-(coords[i0][2]||0)):0;
      const dE=energyStepKJ(d,dz,mass,flat);
      acc+=dE;
      if(acc>=thrKJ){
        out.push({name:'休憩',lat:coords[i1][1],lon:coords[i1][0],routeD:cum[i1],type:'via',isRest:true});
        acc=0;
      }
    }
  }
  return out;
}
async function ensureRests(){
  // 既存休憩を一旦除去→プレビューから再生成
  pts=pts.filter(p=>!p.isRest); fixType(); drawList(); if(pts.length<2) return;
  const profile='cycling-road', mass=75, flat=18, thrKJ=500;
  const coords=pts.map(p=>[p.lon,p.lat]);
  const preview=await dir({coordinates:coords,elevation:true,preference:'fastest',extra_info:['steepness']},profile);
  const feat=preview.features[0];
  const rests=await makeRestSimple(feat,mass,flat,thrKJ);
  if(rests.length){
    const insertPos=Math.max(pts.length-1,1);
    pts.splice(insertPos,0,...rests);
    fixType(); drawList();
  }
}

/* ====== Overpass: 休憩候補3件抽出 ====== */
async function fetchPoisAround(lat,lon,radiusM){
  const q=`[out:json][timeout:25];(
    node["amenity"="convenience"](around:${radiusM},${lat},${lon});
    node["shop"="supermarket"](around:${radiusM},${lat},${lon});
    node["shop"="chemist"](around:${radiusM},${lat},${lon});
    node["shop"="pharmacy"](around:${radiusM},${lat},${lon});
  );out center 30;`;
  const r=await fetch('https://overpass-api.de/api/interpreter',{method:'POST',body:`data=${encodeURIComponent(q)}`,headers:{'Content-Type':'application/x-www-form-urlencoded'}});
  const data=await r.json();
  return (data.elements||[]).map(e=>({
    lat:e.lat||e.center.lat,
    lon:e.lon||e.center.lon,
    name:(e.tags&&(e.tags['name:ja']||e.tags.name))||e.tags?.brand||'POI'
  }));
}
async function buildRestCandidatesForAll(){
  const rests=pts.filter(p=>p.isRest);
  for(let i=0;i<rests.length;i++){
    const p=rests[i];
    try{
      if(i>0) await sleep(250);
      const pois=await fetchPoisAround(p.lat,p.lon,300);
      pois.forEach(po=>po._d=L.latLng(p.lat,p.lon).distanceTo([po.lat,po.lon]));
      p.restCandidates=pois.sort((a,b)=>a._d-b._d).slice(0,3);
    }catch(e){
      console.warn('候補収集失敗',e);
      p.restCandidates=[];
    }
  }
  drawList();
}

/* ====== 区間メトリクス（preference 切替対応） ====== */
async function getPairMetrics(a,b,preference,profile='cycling-road',mass=75,flat=18){
  const key=`${preference}|${a.lon.toFixed(6)},${a.lat.toFixed(6)}|${b.lon.toFixed(6)},${b.lat.toFixed(6)}`;
  if(pairCache.has(key)) return pairCache.get(key);
  const body={coordinates:[[a.lon,a.lat],[b.lon,b.lat]],elevation:true,preference};
  const res=await dir(body,profile);
  const f=res.features[0];
  const km=f.properties.summary.distance/1000;
  const sec=f.properties.summary.duration;
  let kJ=0; const coords=f.geometry.coordinates;
  for(let i=1;i<coords.length;i++){
    const d=L.latLng(coords[i][1],coords[i][0]).distanceTo([coords[i-1][1],coords[i-1][0]]);
    const dz=(coords[i][2]||0)-(coords[i-1][2]||0);
    kJ+=energyStepKJ(d,dz,mass,flat);
  }
  const val={km,min:sec/60,kJ};
  pairCache.set(key,val);
  return val;
}

/* ====== 組合せ探索（ビーム）＆上位3件抽出 ====== */
function buildGroupsFromPts(){
  const start=pts.find(p=>p.type==='start');
  const goal=pts.find(p=>p.type==='goal');
  const restGroups=pts.filter(p=>p.isRest).map(p=>{
    if(Array.isArray(p.restCandidates)&&p.restCandidates.length){
      return p.restCandidates.map(c=>({name:c.name||'候補',lat:c.lat,lon:c.lon}));
    }
    // 候補が無い場合は元のトリガー点をそのまま1候補として扱う
    return [{name:p.name,lat:p.lat,lon:p.lon}];
  });
  return [[{name:start.name,lat:start.lat,lon:start.lon}], ...restGroups, [{name:goal.name,lat:goal.lat,lon:goal.lon}]];
}

// シンプルな目標（必要なら調整してください）
const TARGET={meanD:20,varD:9,meanT:60,varT:400,meanE:500,varE:100};

function evalCostFromSeries(series){
  const ds=series.map(s=>s.km), ts=series.map(s=>s.min), es=series.map(s=>s.kJ);
  return (mean(ds)-TARGET.meanD)**2 + (variance(ds)-TARGET.varD)**2
       + (mean(ts)-TARGET.meanT)**2 + (variance(ts)-TARGET.varT)**2
       + (mean(es)-TARGET.meanE)**2 + (variance(es)-TARGET.varE)**2;
}

async function topKCombinations(preference, K=3, beamWidth=30){
  const groups=buildGroupsFromPts();
  if(groups.length<2) return [];

  let beam=[{node:groups[0][0], path:[groups[0][0]], legs:[], cost:0}];

  for(let gi=1; gi<groups.length; gi++){
    const next=groups[gi]; const nb=[];
    for(const st of beam){
      for(const cand of next){
        const met=await getPairMetrics(st.node,cand,preference);
        const legs=st.legs.concat([met]);
        const cost=evalCostFromSeries(legs);
        nb.push({node:cand, path:st.path.concat([cand]), legs, cost});
      }
    }
    nb.sort((a,b)=>a.cost-b.cost);
    beam=nb.slice(0,beamWidth);
  }
  return [...beam].sort((a,b)=>a.cost-b.cost).slice(0,K);
}

function renderTopK(listEl, items){
  listEl.innerHTML='';
  if(!items.length){ listEl.innerHTML='<div class="small">候補がありません</div>'; return; }
  items.forEach((it,idx)=>{
    const div=document.createElement('div'); div.className='kcard';
    const heads=it.path.slice(1,it.path.length-1).map(p=>p.name||'休憩').join(' / ');
    div.innerHTML=`<div class="row"><strong>#${idx+1}</strong><span>cost=${it.cost.toFixed(3)}</span></div>
                   <div class="small">休憩選択: ${heads||'（休憩なし）'}</div>
                   <div style="margin-top:6px"><button>この組合せを適用</button></div>`;
    div.querySelector('button').onclick=()=>{ applyPathToRests(it.path); drawRoutes(); };
    listEl.appendChild(div);
  });
}
function applyPathToRests(path){
  const chosenRests=path.slice(1,path.length-1);
  let i=0;
  for(const p of pts){
    if(p.isRest && chosenRests[i]){
      p.lat=chosenRests[i].lat;
      p.lon=chosenRests[i].lon;
      i++;
    }
  }
  drawList();
}

/* ====== ルート描画（最短/最速のみ） ====== */
async function drawRoutes(){
  if(pts.length<2) return alert('2地点以上登録してください');
  Object.values(routeLayers).forEach(l=>{ if(l) map.removeLayer(l); }); routeLayers={};
  if(markerLayer) map.removeLayer(markerLayer);

  // マーカー
  markerLayer=L.layerGroup().addTo(map);
  pts.forEach(p=>{
    const ic=p.type==='start'?ICONS.start:(p.type==='goal'?ICONS.goal:ICONS.via);
    markerLayer.addLayer(L.marker([p.lat,p.lon],{icon:ic}).bindTooltip(p.name));
  });

  const coords=pts.map(p=>[p.lon,p.lat]);
  const base={coordinates:coords,elevation:true};

  try{
    if($('showShortest').checked){
      const r1=await dir({...base,preference:'shortest'},'cycling-road');
      routeLayers.short=L.geoJSON(r1.features[0],{pane:'routeShortest',style:{color:'#ff0000',weight:5}}).addTo(map);
    }
    if($('showFastest').checked){
      const r2=await dir({...base,preference:'fastest'},'cycling-road');
      routeLayers.fast=L.geoJSON(r2.features[0],{pane:'routeFastest',style:{color:'#0066ff',weight:5,dashArray:'4 4'}}).addTo(map);
    }
    // 表示範囲フィット
    let b=null; Object.values(routeLayers).forEach(l=>{ if(l){ b=b? b.extend(l.getBounds()) : l.getBounds(); }});
    if(b) map.fitBounds(b.pad(0.1));
  }catch(e){
    console.error(e);
    alert('ルート取得失敗: '+e.message);
  }
}

/* ====== 両モードで上位3を計算 → 表示 ====== */
async function solveBothModes(){
  $('optStatus').textContent='計算中...';
  const [shortTop, fastTop] = await Promise.all([
    topKCombinations('shortest',3,30),
    topKCombinations('fastest',3,30)
  ]);
  renderTopK($('listShortest'), shortTop);
  renderTopK($('listFastest'), fastTop);
  $('optStatus').textContent='完了。上から良い順です。任意の「適用」を押してください。';
}
</script>
</body>
</html>
