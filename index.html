<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>自転車ルート比較＋自動休憩（連続上り対応） v5.6.0</title>

<!-- ライブラリ -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<script  src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script  src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script  src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
/* 画面レイアウト */
body{margin:0;font-family:system-ui,sans-serif}
#map{height:500px;width:100%}
#controls{display:flex;flex-wrap:wrap;gap:8px;padding:8px;background:#f7f7f7}
#pointList{list-style:none;margin:0;padding:0}
#pointList li{display:flex;align-items:center;justify-content:space-between;padding:4px 8px;border:1px solid #ccc;background:#fafafa;margin-bottom:4px;cursor:move}
button.del{background:#d9534f;color:#fff;border:none;border-radius:4px;padding:0 6px;font-size:12px}
#searchResults{position:absolute;z-index:1000;width:260px;max-height:200px;overflow-y:auto;margin:4px 0 0;padding:0;list-style:none;border:1px solid #ccc;background:#fff}
#searchResults li{padding:4px 8px;cursor:pointer}
#searchResults li:hover{background:#e0e0e0}
#summary{padding:8px;background:#fafafa;border-top:1px solid #ddd;font-size:0.9rem}
.section{padding:8px;background:#fff;border-top:1px solid #eee}
.group{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
.muted{color:#666;font-size:0.85em}
.presetKJ{border:1px solid #ccc;border-radius:14px;padding:2px 8px;font-size:.85em;background:#fff;cursor:pointer}
.presetKJ:hover{background:#f0f0f0}
details{border:1px solid #ddd;border-radius:6px;padding:6px;background:#fff}
#charts{display:none}
#charts canvas{width:800px;height:400px}
.small{font-size:.9em;color:#555}
</style>
</head>
<body>

<!-- ────────── 入力 UI ────────── -->
<div id="controls">
  <input id="placeInput" placeholder="地名・住所" style="width:260px">
  <button id="searchBtn">検索</button>
  <label><input type="checkbox" id="nearbyOnly"> 近くの場所のみ</label>
  <button id="locBtn">現在地追加</button>

  <input id="restToggle" type="checkbox" checked hidden>
  <button id="restModeBtn">休憩込み: ON</button>

  <button id="btnDownloadTime"  disabled>PNG（時間×累積kJ）</button>
  <button id="btnDownloadDist"  disabled>PNG（距離×累積kJ）</button>

  <label>基準
    <select id="restBasis">
      <option value="time">時間</option>
      <option value="energy" selected>kJ</option>
    </select>
  </label>

  <span id="timeBox" class="group" style="display:none">
    <label>間隔 <input id="restMinutes" type="number" value="60" min="15" step="5" style="width:70px"> 分</label>
  </span>
  <span id="energyBox" class="group">
    <label>しきい値 <input id="restKJ" type="number" value="500" min="100" step="50" style="width:90px"> kJ</label>
    <button type="button" class="presetKJ" data-kj="400">400</button>
    <button type="button" class="presetKJ" data-kj="500">500</button>
    <button type="button" class="presetKJ" data-kj="650">650</button>
  </span>

  <select id="profileSelect">
    <option value="cycling-road" selected>ロードバイク</option>
    <option value="cycling-regular">自転車（一般）</option>
  </select>
  <button id="drawBtn">ルート表示</button>

  <label><input type="checkbox" id="chkShortest" checked> 最短</label>
  <label><input type="checkbox" id="chkFastest" checked> 最速</label>
  <label><input type="checkbox" id="chkSlope" checked> 勾配</label>
</div>

<div class="section">
  <div class="group">
    <label>体重 <input id="riderWeight" type="number" value="65" min="30" max="150" step="0.5" style="width:80px"> kg</label>
    <label>バイク重量 <input id="bikeWeight" type="number" value="10" min="5" max="30" step="0.1" style="width:80px"> kg</label>
  </div>

  <details open><summary>休憩場所の条件</summary>
    <div class="small">対象カテゴリはチェックで選択（既定：4種）。必要なら下の入力で上書き可能。</div>
    <div class="group" id="poiCats">
      <label class="chk"><input type="checkbox" data-cat="451" id="cat-conv" checked> コンビニ</label>
      <label class="chk"><input type="checkbox" data-cat="443" id="cat-sup"  checked> スーパー</label>
      <label class="chk"><input type="checkbox" data-cat="624" id="cat-michi" checked> 道の駅</label>
      <label class="chk"><input type="checkbox" data-cat="518" id="cat-drug" checked> ドラッグストア</label>
    </div>
    <div class="small">上級者向け: カンマ区切りで上書き → <input id="customCats" placeholder="例: 451,443,624,518" style="width:200px"></div>
  </details>

  <details open><summary>急坂での休憩を追加（連続上り検出）</summary>
    <div class="group">
      <label class="chk"><input type="checkbox" id="restBeforeHill"> 上り区間の前に休憩</label>
      <label class="chk"><input type="checkbox" id="restAfterHill" > 上り区間の後に休憩</label>
      <label>しきい値（平均勾配） <input id="slopeThreshold" type="number" value="6" min="3" max="15" step="0.5" style="width:70px"> %</label>
      <label>前に置く距離 <input id="beforeOffset" type="number" value="150" min="0" max="1000" step="10" style="width:70px"> m</label>
      <label>後に置く距離 <input id="afterOffset"  type="number" value="100" min="0" max="1000" step="10" style="width:70px"> m</label>
    </div>
    <div class="small">※ 連続する上り step を束ね、入口/出口に休憩候補を置きます（平均勾配がしきい値以上、長さや獲得標高の最低条件あり）。</div>
  </details>

  <details><summary>詳細設定（簡易エネルギーモデル）</summary>
    <div class="muted">平坦係数 (kJ/km)</div>
    <label>平坦係数 <input id="flatKJperKm" type="number" value="18" min="10" max="30" step="0.5" style="width:90px"> kJ/km</label>
  </details>
</div>

<ul id="searchResults" hidden></ul>
<ul id="pointList"></ul>
<div id="map"></div>

<div id="summary">
  <div id="routeInfo"></div>
  <div id="distanceScore" class="muted"></div>
</div>

<!-- 画像化用オフスクリーン -->
<div id="charts">
  <canvas id="energyChart"></canvas>
</div>

<script>
/* ===== 定数 ===== */
const ORS_KEY  = '5b3ce3597851110001cf62481af47799d9c344bf86dd4b340f9f9ff9';  // ←★ここに自分のキー
const ORS_ROOT = 'https://api.openrouteservice.org';
const PROXY    = 'https://api.allorigins.win/raw?url='; // /pois 用CORSプロキシ
const DEFAULT_POI_CATS = [451,443,624,518]; // コンビニ,スーパー,道の駅,ドラッグ

const RADII    = [1000,2000,3500];
const CLOSE_TO_GOAL_M = 500;
const MIN_GAP_BETWEEN_RESTS_M = 150; // 休憩点の重複防止（直線距離ベース）

/* ===== ヘルパ ===== */
const $ = id=>document.getElementById(id);
const sleep = ms=>new Promise(r=>setTimeout(r,ms));
const icon  = c=>new L.Icon({iconUrl:`https://maps.gstatic.com/mapfiles/ms2/micons/${c}-dot.png`,iconSize:[32,32],iconAnchor:[16,32]});
const ICONS = {start:icon('green'),via:icon('blue'),goal:icon('red')};
const formatDist = d=>(d/1000).toFixed(2)+' km';
const formatDur  = s=>{const m=Math.round(s/60);return m<60?`${m} 分`:`${Math.floor(m/60)} 時間 ${m%60} 分`;};
const steepSum   = f=>(f.properties.extras.steepness?.values||[]).reduce((s,e)=>s+Math.abs(e[2]||0),0);

/* ===== 状態 ===== */
let pts=[], map, markerLayer, routeLayers={}, lastDirTs=0;
let lastFastest=null,lastMass=0,lastFlat=18;

/* ===== 初期化 ===== */
window.addEventListener('DOMContentLoaded',()=>{
  map=L.map('map').setView([34.07,134.55],11);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'©OpenStreetMap'}).addTo(map);
  map.createPane('routeSlope').style.zIndex=690;
  map.createPane('routeShortest').style.zIndex=700;
  map.createPane('routeFastest').style.zIndex=710;

  $('searchBtn').onclick   = ()=>{const q=$('placeInput').value.trim();q&&nomSearch(q);};
  $('locBtn').onclick      = addCurrent;
  $('drawBtn').onclick     = drawRoutes;

  $('btnDownloadTime').onclick = ()=>downloadEnergyGraphByTime(lastFastest,lastMass,lastFlat);
  $('btnDownloadDist').onclick = ()=>downloadEnergyGraphByDistance(lastFastest,lastMass,lastFlat);

  $('restModeBtn').onclick = ()=>{ $('restToggle').checked=!$('restToggle').checked; $('restModeBtn').textContent='休憩込み: '+($('restToggle').checked?'ON':'OFF'); drawRoutes(); };
  $('restBasis').onchange  = e=>{ const v=e.target.value; $('timeBox').style.display=v==='time'?'inline-flex':'none'; $('energyBox').style.display=v==='energy'?'inline-flex':'none'; };
  document.addEventListener('click',e=>{const b=e.target.closest('.presetKJ');if(b) $('restKJ').value=b.dataset.kj;});
  initSortable();
});

/* ===== Nominatim 検索 ===== */
async function nomSearch(q){
  let url=`https://nominatim.openstreetmap.org/search?format=json&limit=10&q=${encodeURIComponent(q)}`;
  if($('nearbyOnly').checked){
    const b=map.getBounds();
    url+=`&viewbox=${[b.getWest(),b.getNorth(),b.getEast(),b.getSouth()].join(',')}&bounded=1`;
  }
  const arr=await (await fetch(url)).json();
  const ul=$('searchResults'); ul.innerHTML=''; ul.hidden=!arr.length;
  arr.forEach(o=>{
    const li=document.createElement('li'); li.textContent=o.display_name;
    li.onclick=()=>{addPoint({name:o.display_name,lat:+o.lat,lon:+o.lon});ul.hidden=true;$('placeInput').value='';};
    ul.appendChild(li);
  });
}

/* ===== リスト操作 ===== */
function addPoint(p){p.type=pts.length?'':'start';pts.forEach(d=>d.type==='goal'&&(d.type='via'));pts.push(p);if(pts.length>1)pts.at(-1).type='goal';drawList();}
function drawList(){
  const ul=$('pointList');ul.innerHTML='';
  pts.forEach((p,i)=>{
    const li=document.createElement('li');li._idx=i;
    li.innerHTML=`<span>${p.name}${p.isRest?'（休憩）':''}</span>`;
    const del=document.createElement('button');del.className='del';del.textContent='×';
    del.onclick=e=>{e.stopPropagation();pts.splice(i,1);fixType();drawList();};
    ul.appendChild(li);li.appendChild(del);
  });
}
function fixType(){if(pts[0])pts[0].type='start';if(pts.length>1)pts.at(-1).type='goal';}
function initSortable(){new Sortable($('pointList'),{animation:150,handle:'span',onEnd:()=>{pts=Array.from($('pointList').children).map(li=>pts[li._idx]);fixType();drawList();}});}

/* ===== 現在地 ===== */
function addCurrent(){navigator.geolocation.getCurrentPosition(p=>addPoint({name:'現在地',lat:p.coords.latitude,lon:p.coords.longitude}),()=>alert('現在地取得失敗'));}

/* ===== Directions API ===== */
async function post(url,body){const r=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json','Authorization':ORS_KEY},body:JSON.stringify(body)});if(!r.ok) throw new Error(r.status);return r.json();}
async function dir(body,profile){const wait=1100-(Date.now()-lastDirTs);if(wait>0) await sleep(wait);const d=await post(`${ORS_ROOT}/v2/directions/${profile}/geojson`,body);lastDirTs=Date.now();return d;}

/* ===== POI カテゴリ取得（UI） ===== */
function getSelectedCatIds(){
  const custom = $('customCats').value.trim();
  if(custom){
    const arr = custom.split(',').map(s=>+s.trim()).filter(n=>Number.isFinite(n));
    if(arr.length) return arr;
  }
  const boxes = [...document.querySelectorAll('#poiCats input[type=checkbox]')];
  const sel = boxes.filter(b=>b.checked).map(b=>+b.dataset.cat);
  return sel.length ? sel : DEFAULT_POI_CATS.slice();
}

/* ===== POI 取得 (プロキシ経由) ===== */
async function nearPoi(lat,lon, categoryIds){
  for(const buf of RADII){
    const qs=new URLSearchParams({
      api_key:ORS_KEY,request:'pois',limit:20,sortby:'distance',
      geometry:JSON.stringify({buffer:buf,geojson:{type:'Point',coordinates:[lon,lat]}}),
      filters :JSON.stringify({category_ids:categoryIds})
    });
    try{
      const url = `${ORS_ROOT}/pois?${qs.toString()}`;
      const r   = await fetch(PROXY+encodeURIComponent(url));
      if(!r.ok) throw new Error();
      const d=await r.json();
      if(d.features?.length) return d.features[0];
    }catch{}
  }
  return {geometry:{coordinates:[lon,lat]},properties:{name:'休憩'}};
}
const isClose=(lat,lon)=>{const g=pts.at(-1);return g?L.latLng(lat,lon).distanceTo([g.lat,g.lon])<=CLOSE_TO_GOAL_M:false;};
const distLL=(aLat,aLon,bLat,bLon)=>L.latLng(aLat,aLon).distanceTo([bLat,bLon]);

/* ===== エネルギー ===== */
const energyStepKJ=(d,dz,m,flat)=>flat*(d/1000)+Math.max(dz,0)*m*9.80665/1000;

/* ===== 連続上り検出関連ユーティリティ ===== */
// ルート各座標の累積距離 [m]
function buildCumDistArray(coords){
  const cd=[0];
  for(let i=1;i<coords.length;i++){
    const [lon,lat]=coords[i];
    cd[i]=cd[i-1]+L.latLng(lat,lon).distanceTo([coords[i-1][1],coords[i-1][0]]);
  }
  return cd;
}
// 任意の routeD 上の緯度経度（線形補間）
function findPointAtRouteD(coords, cum, targetD){
  if(targetD<=0){ const [lon,lat]=coords[0]; return {lat,lon}; }
  const total=cum.at(-1);
  if(targetD>=total){ const [lon,lat]=coords.at(-1); return {lat,lon}; }
  let i=1; while(i<coords.length && cum[i]<targetD) i++;
  const i0=i-1, i1=i, d=cum[i1]-cum[i0]||1, r=(targetD-cum[i0])/d;
  const [lon0,lat0]=coords[i0], [lon1,lat1]=coords[i1];
  return {lat: lat0+(lat1-lat0)*r, lon: lon0+(lon1-lon0)*r};
}
// 連続上り区間を step を束ねて検出
function detectClimbs(coords, segs, cum, opt={grade_start:6, grade_keep:4, min_len:200, min_gain:15}){
  const climbs=[];
  let inClimb=false, startIdx=null, gain=0, len=0;

  const pushIfValid=(endIdx)=>{
    if(len>=opt.min_len || gain>=opt.min_gain){
      const avg = len>0 ? (gain/len)*100 : 0;
      climbs.push({start:startIdx, end:endIdx, len, gain, avg});
    }
  };

  for(const seg of segs){
    for(const st of seg.steps){
      const [i0,i1]=st.way_points;
      const d = (cum[i1]-cum[i0])||0;
      const z0=(coords[i0][2]||0), z1=(coords[i1][2]||0);
      const dz = z1 - z0;
      const grade = d>0 ? (dz/d)*100 : 0;

      if(!inClimb){
        if(dz>0 && grade>=opt.grade_start){
          inClimb=true; startIdx=i0; gain=dz; len=d;
        }
      }else{
        if(dz>0 && grade>=opt.grade_keep){
          gain+=dz; len+=d;
        }else{
          // 終了
          pushIfValid(i0);
          inClimb=false; startIdx=null; gain=0; len=0;
        }
      }
    }
  }
  if(inClimb) pushIfValid(coords.length-1);
  return climbs;
}

/* ===== 休憩ロジック（連続上り対応＋時間/kJ） ===== */
async function makeRest(feat,basis,mass,flat,thr, hillOpts, categoryIds){
  const crd=feat.geometry.coordinates, segs=feat.properties.segments;
  const hasEle=crd[0].length>=3;
  const cum=buildCumDistArray(crd);

  const res=[];
  let acc=0;

  // 近接・ゴール近傍のフィルタ込みで追加
  const pushUnique = async (lat,lon)=>{
    if(isClose(lat,lon)) return;
    if(res.some(r=>distLL(r.lat,r.lon,lat,lon)<MIN_GAP_BETWEEN_RESTS_M)) return;
    const poi=await nearPoi(lat,lon,categoryIds);
    const pLat=poi.geometry.coordinates[1], pLon=poi.geometry.coordinates[0];
    if(isClose(pLat,pLon)) return;
    if(res.some(r=>distLL(r.lat,r.lon,pLat,pLon)<MIN_GAP_BETWEEN_RESTS_M)) return;
    res.push({name:poi.properties.name||'休憩',lat:pLat,lon:pLon,type:'via',isRest:true});
  };

  // 1) 時間 / kJ しきい値による候補
  for(const seg of segs){
    for(const st of seg.steps){
      const [i0,i1]=st.way_points, d=st.distance||0, t=st.duration||0;
      const z0=hasEle?(crd[i0][2]||0):0, z1=hasEle?(crd[i1][2]||0):0, dz=z1-z0;
      acc += (basis==='time') ? t : energyStepKJ(d,dz,mass,flat);
      if(acc>=thr){
        const [lon,lat]=crd[i1];
        await pushUnique(lat,lon);
        acc=0;
      }
    }
  }

  // 2) 連続上りの入口/出口に候補
  if(hillOpts?.before || hillOpts?.after){
    const th = Number(hillOpts.th)||6;
    const climbs = detectClimbs(crd, segs, cum, {
      grade_start: th,
      grade_keep : Math.max(th-2, 2),
      min_len: 200,
      min_gain: 15
    });
    for(const c of climbs){
      if(hillOpts.before){
        const targetD = Math.max(0, cum[c.start] - (Number(hillOpts.beforeOff)||150));
        const P = findPointAtRouteD(crd, cum, targetD);
        await pushUnique(P.lat, P.lon);
      }
      if(hillOpts.after){
        const targetD = Math.min(cum.at(-1), cum[c.end] + (Number(hillOpts.afterOff)||100));
        const P = findPointAtRouteD(crd, cum, targetD);
        await pushUnique(P.lat, P.lon);
      }
    }
  }

  return res;
}

/* ===== グラフ共通（オフスクリーン描画） ===== */
function tempShowChartsContainer(show){
  const charts = $('charts');
  if(show){
    charts.style.display = 'block';
    charts.style.position = 'absolute';
    charts.style.left = '-99999px';
    charts.style.top = '0';
    charts.style.visibility = 'hidden';
  }else{
    charts.removeAttribute('style');
    charts.style.display = 'none';
  }
}
function prepareCanvasSize(canvas, w=1600, h=900){
  canvas.width  = w;
  canvas.height = h;
}

/* ===== 時間×累積kJ ===== */
function buildEnergyTimeSeriesBySteps(feature, mass, flat){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length >= 3;
  let cumT = 0, cumE = 0;
  const tMin=[], eKJ=[];
  for(const seg of feature.properties.segments){
    for(const st of seg.steps){
      const [i0,i1] = st.way_points;
      const d  = st.distance || 0;
      const dt = st.duration || 0;
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      const dE = energyStepKJ(d,dz,mass,flat);
      cumT += dt; cumE += dE;
      tMin.push((cumT/60).toFixed(2));
      eKJ .push(+cumE.toFixed(1));
    }
  }
  return { labels:tMin, values:eKJ, xlabel:'時間 (分)', ylabel:'累積エネルギー (kJ)', filename:'energy_over_time.png' };
}
function downloadEnergyGraphByTime(fastestFeature, mass, flat){
  if(!fastestFeature){ alert('先にルートを描画してください'); return; }
  const series = buildEnergyTimeSeriesBySteps(fastestFeature, mass, flat);
  downloadLineChart(series);
}

/* ===== 距離×累積kJ ===== */
function buildEnergyDistanceSeriesBySteps(feature, mass, flat){
  const coords = feature.geometry.coordinates;
  const hasEle = coords[0].length >= 3;
  let cumD = 0, cumE = 0;
  const km=[], eKJ=[];
  for(const seg of feature.properties.segments){
    for(const st of seg.steps){
      const [i0,i1] = st.way_points;
      const d  = st.distance || 0; // m
      const dz = hasEle ? ((coords[i1][2]||0)-(coords[i0][2]||0)) : 0;
      const dE = energyStepKJ(d,dz,mass,flat);
      cumD += d;      // m
      cumE += dE;     // kJ
      km .push((cumD/1000).toFixed(2));
      eKJ.push(+cumE.toFixed(1));
    }
  }
  return { labels:km, values:eKJ, xlabel:'距離 (km)', ylabel:'累積エネルギー (kJ)', filename:'energy_over_distance.png' };
}
function downloadEnergyGraphByDistance(fastestFeature, mass, flat){
  if(!fastestFeature){ alert('先にルートを描画してください'); return; }
  const series = buildEnergyDistanceSeriesBySteps(fastestFeature, mass, flat);
  downloadLineChart(series);
}

/* ===== 共有ダウンロード関数 ===== */
function downloadLineChart({labels, values, xlabel, ylabel, filename}){
  tempShowChartsContainer(true);
  const ec = $('energyChart');
  prepareCanvasSize(ec, 1600, 900);

  const ch = new Chart(ec, {
    type: 'line',
    data: { labels, datasets: [{ label: ylabel, data: values, borderWidth:2, pointRadius:0 }] },
    options: {
      animation:false,
      plugins:{ legend:{ display:false } },
      scales:{
        x:{ title:{ display:true, text: xlabel } },
        y:{ title:{ display:true, text: ylabel } }
      }
    }
  });

  setTimeout(()=>{
    ec.toBlob(b=>{
      if(!b){ alert('PNG 生成に失敗'); return; }
      const u=URL.createObjectURL(b);
      const a=document.createElement('a'); a.href=u; a.download=filename; a.click();
      setTimeout(()=>URL.revokeObjectURL(u),1000);
      ch.destroy();
      tempShowChartsContainer(false);
    },'image/png');
  },120);
}

/* ===== ルート描画（連続上り対応版） ===== */
async function drawRoutes(){
  $('btnDownloadTime').disabled=true;
  $('btnDownloadDist').disabled=true;
  lastFastest=null;

  if(pts.length<2){alert('2地点以上登録してください');return;}

  // レイヤクリア
  Object.values(routeLayers).forEach(l=>l&&map.removeLayer(l)); routeLayers={};
  if(markerLayer) map.removeLayer(markerLayer);

  // 以前の休憩を除去
  pts = pts.filter(p => !p.isRest);
  fixType();
  drawList();

  const profile=$('profileSelect').value;
  const mass=Number($('riderWeight').value)+Number($('bikeWeight').value);
  const flat =Number($('flatKJperKm').value);
  const basis=$('restBasis').value;
  const thr  =basis==='time'?Number($('restMinutes').value)*60:Number($('restKJ').value);

  // 連続上りのオプション
  const hillOpts = {
    before: $('restBeforeHill').checked,
    after : $('restAfterHill').checked,
    th    : Number($('slopeThreshold').value)||6,
    beforeOff: Number($('beforeOffset').value)||150,
    afterOff : Number($('afterOffset').value)||100
  };
  const categoryIds = getSelectedCatIds();

  // 休憩プレビュー→挿入
  try{
    if($('restToggle').checked){
      const preview=await dir({
        coordinates:pts.map(p=>[p.lon,p.lat]),
        elevation:true, extra_info:['steepness'], preference:'fastest'
      },profile);

      const rests=await makeRest(preview.features[0],basis,mass,flat,thr, hillOpts, categoryIds);
      if(rests.length){
        const insertPos=Math.max(pts.length-1,1);
        pts.splice(insertPos,0,...rests);
        fixType();
        drawList();
      }
    }
  }catch(e){console.warn('休憩地点取得失敗',e);}

  // マーカー描画（休憩挿入後）
  markerLayer=L.layerGroup().addTo(map);
  pts.forEach(p=>{
    const ic=p.type==='start'?ICONS.start:p.type==='goal'?ICONS.goal:ICONS.via;
    const mk=L.marker([p.lat,p.lon],{icon:ic}).bindTooltip(p.name+(p.isRest?'（休憩）':''));
    markerLayer.addLayer(mk);
  });

  // ルート本体
  const coords=pts.map(p=>[p.lon,p.lat]), base={coordinates:coords,elevation:true,extra_info:['steepness']};
  try{
    const shortest = await dir({...base,preference:'shortest'},profile);
    const fastest  = await dir({...base,preference:'fastest'},profile);
    let slope=shortest.features[0];
    if(coords.length===2){
      const alt=await dir({...base,preference:'shortest',alternative_routes:{target_count:3,share_factor:0.6,weight_factor:1.4}},profile);
      slope=alt.features.reduce((a,b)=>steepSum(a)<steepSum(b)?a:b);
    }

    routeLayers.short=L.geoJSON(shortest.features[0],{pane:'routeShortest',style:{color:'#ff0000',weight:6}}).addTo(map);
    routeLayers.fast =L.geoJSON(fastest.features[0] ,{pane:'routeFastest' ,style:{color:'#0066ff',weight:6,dashArray:'4 4'}}).addTo(map);
    routeLayers.slope=L.geoJSON(slope               ,{pane:'routeSlope'  ,style:{color:'#ff9900',weight:6,opacity:0.9}}).addTo(map);
    updateLayerVisibility();

    const bounds=new L.LatLngBounds();
    markerLayer.eachLayer(l=>bounds.extend(l.getLatLng()));
    Object.values(routeLayers).forEach(l=>bounds.extend(l.getBounds()));
    if(bounds.isValid()) map.fitBounds(bounds.pad(0.1));

    const s1=shortest.features[0].properties.summary,s2=fastest.features[0].properties.summary,s3=slope.properties.summary;
    $('routeInfo').innerHTML=
      `<b>最短</b> ${formatDist(s1.distance)} / ${formatDur(s1.duration)}<br>`+
      `<b>最速</b> ${formatDist(s2.distance)} / ${formatDur(s2.duration)}<br>`+
      `<b>勾配</b> ${formatDist(s3.distance)} / ${formatDur(s3.duration)}`;
    $('distanceScore').textContent=`距離差: ${(s2.distance-s1.distance).toFixed(0)} m`;

    lastFastest=fastest.features[0]; lastMass=mass; lastFlat=flat;
    $('btnDownloadTime').disabled=false;
    $('btnDownloadDist').disabled=false;
  }catch(e){console.error(e);alert('ルート取得失敗: '+e.message);}
}
function updateLayerVisibility(){const m={short:'chkShortest',fast:'chkFastest',slope:'chkSlope'};for(const k in routeLayers){routeLayers[k]&&($(m[k]).checked?routeLayers[k].addTo(map):map.removeLayer(routeLayers[k]));}}
</script>
</body>
</html>
